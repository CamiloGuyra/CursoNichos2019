---
title: "Introducción a R"
date: "`r Sys.Date()`"
author: "Luis Osorio Olvera (luismurao@gmail.com)"
output:
  rmdformats::readthedown:
    code_folding: show
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: true
    highlight: tango
    df_print: kable 
    toc_depth: 6
    
---

<style type="text/css">

body{ /* Normal  */
      font-size: 16px;
  }
td {  /* Table  */
  font-size: 12px;
}
code.r{ /* Code block */
    font-size: 16px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 16px;
}
</style>



## Resumen

En el presente documento se da una breve introducción al lenguaje [R](https://www.r-project.org/). Exploraremos desde las funciones más básicas del lenguaje (como leer tablas de datos, hacer aritmética, algunas operaciones algebraicas) hasta cómo utilizar funciones de paquetes especializados para el análisis espacial (*i.e.* [`raster`](https://cran.r-project.org/web/packages/raster/index.html), [`rgdal`](https://cran.r-project.org/web/packages/rgdal/index.html), [`dismo`](https://cran.r-project.org/web/packages/dismo/index.html)). También se hará énfansis en cómo programar funciones propias o funciones definidas por el usuario (**helper functions**) las cuales tienen el objetivo de facilitarnos tareas complejas. Es importante notar que operaciones básicas como la indexación suelen ser vitales para poder realizar operaciones mucho más complicadas y complejas dentro de los loops y estructuras de control. 

## Qué es, de dónde y cómo instalo R? 

R es un lenguaje de programación de código abierto el cual está basado en el lenguaje S. En sus inicios el lenguaje realizaba solo operaciones estadísticas y gráficas, sin embargo a través de los años se ha convertido en un lenguaje polifacético en donde podemos encontrar desde paquetes para el análisis de textos (text mining), web scraping, análisis espaciales (*i.e.* [`spatstat`](https://cran.r-project.org/package=spatstat )) hasta para la programación de aplicaciones web (*i.e* [`shiny`](https://cran.r-project.org/web/packages/shiny/index.html)). Lo anterior se debe a que varios de sus usuarios se han convertido en desarrolladores activos de la comunidad. Acutualmente existen casi 11000 paquetes (Fig. 1), el crecimiento de estos ha sido exponencial (Fig. 2). 

![Figura_1](Figuras_01Intro/text4138.png)
<p align="center">Figura 1. Número de paquetes en [CRAN](https://cran.r-project.org/)</p>

```{r eval=TRUE, echo=FALSE, cache=FALSE,  message=FALSE, warning=FALSE, fig.align='center',fig.width=8}
library(dygraphs)
data_pkgs <- read.csv("Arichivos_01Intro/paquetesTS.csv")
pkgs <- data_pkgs[,2:3]
row.names(pkgs) <- as.Date(pkgs[,2])
dygraph(pkgs) %>% dyRangeSelector() 

```
<p align="center">Figura 2. Serie de tiempo del número de paquetes en [CRAN](https://cran.r-project.org/)</p>

#### Obtención e instalación de R

R se puede descargar de la siguiente página web <http://www.r-project.org/>. 
![Figura_3](Figuras_01Intro/r_website.png)

En el panel izquierdo encontrarás la opción de [**download**](http://cran.r-project.org/mirrors.html) donde elegirás un mirror para descargarlo, los links para México son los siguientes: 

- <https://cran.itam.mx/>
- <http://cran.itam.mx/>
- <http://www.est.colpos.mx/R-mirror/>
- <http://cran.jellyfish.lol/>

Elige el link de descarga que te parezca más adecuado en función del área en que te encuentres. Una vez elegido el mirror, selecciona la versión de R de acuerdo a tu sistema operativo (**Linux**, **Mac** o **Windows**).

![Figura_4](Figuras_01Intro/itamMirror.png)

La forma más fácil de instalar R es por medio de los binarios (o ejecutables), sin embargo si deseas instalarlo desde teminal de Linux o Mac aquí puedes encontrar las instrucciones:

- MAC <https://rud.is/b/2015/10/22/installing-r-on-os-x-100-homebrew-edition/>
- Linux (Ubuntu) <https://cran.r-project.org/bin/linux/ubuntu/README>

Antes de empezar con el tutorial voy a fijar una semilla aleatoria para que los ejemplos de este documento sean reproducibles (es decir, para que todos en el grupo lleguen a los mismos resultados).

```{r}
set.seed(111)
```



## Tutorial: Introducción a R

Una vez que han instalado R en sus computadoras ahora estamos listos para comenzar a aprender programación en este ambiente maravilloso. 

### Sintaxis 

La primera cosa que hay que explorar es la sintaxis del lenguaje; en esta sección daremos un panorama general de ella. La primera cosa que hay que tener en cuenta sobre la sintaxis de R es que a diferencia de otros lenguajes como `SQL`, `BASIC`, `Pascal`, `R` es sensible a mayúsculas y minúsculas por lo que un objeto llamado **libro** es diferente a **Libro**. Veamos el ejemplo:

```{r}
libro <- "En las montañas de la locura"
# Existe en la memoria de R el objeto libro?
exists("libro")
# y que hay sobre el objeto Libro?
exists("Libro")

```

A pesar de que no se comentó anteriormente (se dio por hecho), en R la forma de declarar variables es mediante el comando de asignación (***<-***). Aunque también es posible declarar las variables con el signo (***=***) se recomienda usar ***<-***. Veremos más sobre variables en las siguientes secciones

```{r}
# Asigna a uno el valor numérico 1 usando el comando "<-" 
uno <- 1
# Alternativamente 
1 -> uno
# Asigna a dos el valor numérico 2 usando el comando "=" 
dos = 2
# Asignar el valor 3 a la variable 3 usando el comando assing
assign("tres", 3)
print(uno)
print(dos)
print(tres)

```

Otra característica de la sintaxis es que en R solo se permite nombrar a las variables comenzando con letras (mayúsculas o minúsculas) o **"."*** y nunca con números.

```{r}
Olor <- "Dulce"
olor <- "Agradable"
# Esto produce un error
# 0lor <- "Fétido" # la variable comienza con el digito cero
print(Olor)
print(olor)

```

Las variables pueden contener números en cualquier otra posición (nunca al comienzo).

```{r}
ol0r <- "fresco"
o1or <- "fresco"
print(ol0r)
print(o1or)
```

Ahora probemos con el **"."***

```{r}
.ayuda <- "SOS"
print(.ayuda)
```

### R como calculadora

La consola de R puede ser usada como calculadora aritmética, vemos algunas operaciones básicas:

Una suma
```{r}
5 + 89
```
Una resta 
```{r}
18 - 167
```
Una multiplicación
```{r}
2 * 98
```
División 
```{r}
6/5
```
Potencia 
```{r}
9 ^ 9
```
El residuo de la división
```{r}
9 %% 7
```
La parte entera 
```{r}
9 %/% 7
```
Podemos verificar que 9 es la suma de su residuo más 7 veces la parte entera de la fracción
```{r}
# Residuo + 7 * la parte entera de la fracción
(9 %% 7) + 7 * (9 %/% 7) 
```

Los paréntesis puede ser usados para especificar el orden de las operaciones 
```{r}
(1 + 1/300)^300
```

R contiene algunas funciones matemáticas ya incluidas como $\sin(x)$, $\cos(x)$, $\tan(x)$, (en radianes), $\exp(x)$, $\log(x)$ y $\sqrt{x}$. 

```{r}
exp(1)
sin(1)
cos(1)
log(1)
sqrt(1)
```

También tiene en memoria algunas constantes como $\pi$  
```{r}
pi
```

Podemos especificar la precisión de las salidas con el comando options
```{r}
options(digits = 16)
pi
```

Redondear cantidades 
```{r}
# Redondea dos digitos de precisión
round(10/3.4, 2)
# Entero mayor más cercano
ceiling(1/3)
# El entero menor más cercano
floor(1/3)
```

## Variables (Global environment)

R tiene un ambiente de trabajo conocido como ambiente global (***Global environment***) en donde se guardan los resultados de los cálculos. Los resultados se guardan en forma de objetos o variables; una variable es como un folder etiquetado donde guardamos documentos, éstos puede ser de diversa naturaleza y siempre tenemos la opción de cambiar el contenido de ellos, sin embargo, el folder se llamará de la misma manera. 

Las variables globales se encuentran en el ***Global environment*** y pueden ser llamadas en cualquier momento durante la sesión; así, si quisiéramos almacenar una cantidad, digamos la tasa de interés anual a la que pagaremos un coche, podemos guardarla en la variable *i.e.* **tasa_anual** y utilizarla cuando la necesitemos.

Imaginemos que vamos a comprar un [Audi RS5 4.2 FSI 450 hp](http://www.audi.com.mx/mx/brand/es2/Modelos/a5/a5-coupe1/fichas_tecnicas.html) y que queremos pagarlo a 48 meses (4 años). La tasa anual que maneja audi es aproximadamente de 12.9%; olvidándonos de los pagos de comisión por apertura etc. hagamos el cálculo de cuánto pagaremos por nuestro [Audi](http://www.audi.com.mx/mx/brand/es2.html) (Fig. 5). 

![figura_5](Figuras_01Intro/audi-rs5.jpg)
<p align="center">Figura 5. [Audi RS5 4.2 FSI 450 hp](http://www.audi.com.mx/mx/brand/es2/Modelos/a5/a5-coupe1/fichas_tecnicas.html)</p>

```{r}
# Auto Audi RS5 4.2 FSI 450 hp precio de lista
audi_rs5 <- 1484900.00
# Tasa anual de 12.9%
tasa_anual <- 0.129
# Cuanto pagaremos de interes en un año
(interes_anual <- audi_rs5*tasa_anual)
# Y en los cuatro años
(interes_4 <- audi_rs5*(tasa_anual*4))
# Total a pagar 
(total_audi_rs5 <- audi_rs5 + interes_4)
```

### Los vectores y matrices en R

Comencemos con algunas definiciones necesarias:

- **Escalar:** Un escalar es sólo una cantidad numérica *i.e.* un entero o un número real. 
- **Vector:** Se llama vector de dimensión $n$ a una tupla de $n$ números reales o componentes del vector (un vector está constituido por 1 o varios escalares).

El conjunto de todos los vectores de dimensión $n$, se representa como $\mathbb{R}^n$. Así, un vector ${\textbf v}$ perteneciente a un espacio $\mathbb{R}^n$ se representa como:

${\textbf v} = (a_1, a_2, a_3, \dots, a_n)$ donde ${\textbf v} \in \mathbb{R}^n$

En matemáticas existen dos tipos de vectores, el vector renglón (el de la ecuación de arriba) y el vector columna.  

#### Vector columna 

$$\textbf v= \left(
\begin{array}{c}
a_1\\
a_2\\
\vdots\\
a_n\\
\end{array}
\right)$$

Para saber más sobre las operaciones matemáticas de vectores y matrices en R da clic [aquí](./01b_vectores_matrices.html). 


### Indexación de vectores en R

Nótese que se puede localizar a cada componente del vector por su posición (ver ejemplo).

$$\textbf f = (5,2,4,3)$$

De modo que la componente 3 del vector $\textbf f$ es el número $4$.
En R, a lo anterior se le denomina **indexación** y es una de las herramientas más poderosas que podemos aprender; si logramos dominar este arte, la programación y automatización de tareas muy complejas será mucho más sencilla. 

El desconocimiento de la forma en cómo se indexan los vectores o matrices hace que el código fuente de los programas o scripts sea obscuro. En los siguientes ejemplos veremos que esta arte es mucho más clara de lo que parece. 

Primero debemos notar que en R la forma más básica de construir vectores es utilizando la función concatenar **"c"**. Este comando concatena a cada uno de los elementos que formarán a nuestro vector. 

```{r}
# Generemos el vector f (el del ejemplo anterior)
f <- c(5,2,4,3)
```

Comprobemos si efectivamente el elemento 3 del vector ${\textbf f}$ es el número $4$
```{r}
f[3]
```

Efectivamente es el número 4 y que hay del primer elemento?
```{r}
f[1]
```

Si quisiéramos extraer más de un elemento (un subconjunto $\textbf f_1$ de dimensión $m$ con $m \le n$) del vector ${\textbf f}$? 

Ahora se muestra como formar un subconjunto $\textbf f_1$ constituido por los elementos 1, 3 y 4 del vector ${\textbf f}$

```{r}
(f1 <- f[c(1,3,4)])
```


**Nota:** En algunos lenguajes como [***python***](https://www.python.org/) la indexación comienza con el 0.


### Generación de secuencias (vectores) regulares en R

R tiene varias formas de generar secuencias, por ejemplo, el comando **1:n** genera la secuencia $1,2,3,\dots,n$. La secuencia anterior es una de las más utilizadas para generar subconjuntos de vectores de dimensión $n$ y cuyos elementos son números enteros. Otro comando que encontraremos con frecuencia es el comando ***"seq"***, este comando genera secuencias de números en el intervalo $[a,b]$ con particiones de tamaño $\delta$. 

Generemos una secuencia de números del 0 al 10 de 2 en 2, es decir $\delta=2$
```{r}
seq(from =0,to = 10,by = 2)
```

Ahora una secuencia de 0 a 1 con $\delta=0.01$
```{r}
seq(0,1,by=0.01)
```

Imaginemos que se quiere una secuencia de números definidos en el intervalo $(13,25)$ pero cuya longitud sea de 40 números. Uno de los argumentos del comando ***seq*** es ***length.out*** y con este se puede especificar la longitud de la secuencia de valores que queremos generar.
```{r}
# longitud de la secuencia que queremos generar
tamano <- 40
seq(13,25,length.out=tamano)
```

### El comando rep

La función `rep` permite generar secuencias repetidas de vectores. 

```{r}
vec <- c("A","B")
rep(vec, 2)
```


### El comando sample

Un comando frecuentemente utilizado para extraer una muestra aleatoria de un vector el comando **sample**. Algunos de sus argumentos son:

- El vector de donde se va a sacar la secuencia aleatoria ($x$). 
- El número de elementos (**size**) que se van a extraer del vector $x$.
- La muestra será obtenida con remplazo (**replace**)

En el siguiente ejemplo crearemos un vector de 1000 elementos y tomaremos una muestra aleatoria de 100. Veamos cómo hacerlo en R!
```{r}
vec <- 1:1000
sample(x = vec,size = 100,replace = FALSE)

```


### Midiendo la longitud de un vector 

Supongamos que estamos creando un algoritmo donde en uno de los pasos se genera un vector $\textbf l$ cuyo tamaño puede variar en función de que se cumpla una condición $c$; imaginemos que estamos interesados en saber cuál es el número promedio de iteraciones que necesita nuestro algoritmo para cumplir la condición $c$. Una forma de averiguar lo anterior es guardar en un vector **n_iter** el número de iteraciones que el algoritmo necesitó en cada una de las simulaciones que relizamos. La pregunta es cómo saber la longitud del vector $\textbf l$: en R es muy sencillo, el comando para realizarlo es ***length***

```{r}
# logitudes posibles de nuestro vector l
tamanos <- 1:30
# tamaño de l
tamano_l <- sample(tamanos,size = 1)
l <- seq(1,5,length.out = tamano_l)
# La longitud de l
length(l)
```



## Las matrices en R  

- **Matriz:** Es un arreglo bidimensional de números donde cada elemento de la matriz $\textbf M$ se puede identidficar por la fila $i$ y la columna $j$ a la que pertenece.

En R las matrices pueden ser de 2 tipos:

1) Numérica 
2) Cadena

Lo anterior quiere decir que no podemos combinar números con caracteres. Si fuera este el caso, R internamente realiza una operación conocida como casteo [cast](http://campus.almagro.ort.edu.ar/informatica/prog/articulo/260037/castear-hacer-cast-) y convierte a todos los elementos a caracteres (strings)

### Creación de matrices en R

Las matrices en R se crean con el comando ***matrix*** y sólo necesitamos indicar los elementos que la conformarán (**data**), el número de filas (**nrow**) y columnas (**ncol**) que contendrá.
```{r}
elementos <- seq(1:16)
mat <- matrix(elementos,nrow = 4,ncol = 4)
print(mat)
```

Como se había mencionado las matrices en R sólo pueden ser de dos tipos numéricas o de cadena de caracteres:
```{r}
# Matriz tipo cadena
letras <- LETTERS[1:9]
mat_carac <- matrix(letras,ncol=3,nrow = 3)
```

Tratemos de combinar números con letras
```{r}
letras_b <- LETTERS[1:8]
numero_b <- 1:8
letras_numeros <- c(letras_b,numero_b)
mat_num_car <- matrix(letras_numeros,ncol=4,nrow = 4)
print(mat_num_car)
```

### Indexación de matrices en R

Sea $\textbf M$ una matriz de $6\times 8$ dimensiones. Supongamos que se nos pide extraer el elemento que corresponde a la fila 3 y al renglón 6. La forma de indexar matrices en R sigue la misma lógica que en matemáticas en donde $\mathbf{M_{fila,columna}}$ en R se indexa como $\mathbf{M[fila,columna]}$. Veamos el código!

```{r}
dats <- seq(2,4,length.out = 48)
M <- matrix(dats,nrow = 6,ncol = 8,byrow = TRUE)
# Extraigo el elemento a_{3,6}
print(M[3,6])
```

También podemos usar la indexación para mostrar una sola fila de la matriz, una columna completa, los primeros $m$ elementos de una fila o una columna, las primeras $k$ columnas y las primeras $r$ filas de la matriz...

### Llamando sólo una fila de una matriz

A continuación se muestra como enlistar la segunda fila de la matriz $\mathbf M$
```{r}
print(M[2,])
```

### Llamando sólo una columna de una matriz

A continuación se muestra como enlistar la tercera columna de la matriz $\mathbf M$
```{r}
print(M[,3])
```

### Combinando formas de indexar

Con las operaciones vistas hasta el momento podemos realizar varias combinaciones para extraer elementos de una `matriz`. Veamos algunos ejemplos de lo anterior.

Dada la matriz $\mathbf {M_{5,5}}$ extraer:

a) las primeras 3 filas de las columnas 1 y 2
```{r}
d_mat <- 1:25
M <- matrix(d_mat,ncol = 5,nrow = 5, byrow = TRUE)
print(M[1:3,c(1,2)])
```

b) Las filas de 1 a la 5 de las columas 1 y 5 
```{r}
print(M[c(1,2,3,4,5),c(1,5)])
```

Para saber más sobre matrices y sus operaciones en R da clic [aquí](./01b_vectores_matrices.html). 

### Los data.frame

Al igual que las matrices, un `data.frame` es un arreglo bidimensional de reglones y columnas. A diferencia de las matrices este permite tener columnas de tipo numérico y de tipo caracter en él. Cada columna representa una variable (en el sentido estadístico). 

### Construcción de `data.frames`

La función `data.frame` permite contruir un `data.frame` a partir de vectores; cada vector representa una variable o columna en el `data.frame`. A continuación veremos cómo construir un `data.frame` cuyas variables son de tipo numérico y de tipo caracter. 

Supón que tienes una granja de pollitos y que tu veterinario te ofrece probar 5 diferentes suplementos para engordar a los pequeños :). Debido a que el veterinario es buenísima onda te surte de manera gratuita suplemento suficiente para alimentar a `r 25*3` durante 3 meses. Dada tu formación cuantitativa se te ocurre diseñar un experimento donde defines como variable de respuesta al peso y como variable explicativa al suplemento. Como hay un total de `r 25*3` pollitos te das cuenta que puedes realizar un experimento balanceado en donde alimentas con el sumplento 1 a 5 pollitos, con el suplemento 2 a otros 5 y así sucesivamente para los 5 tipos de alimento (1 dieta cada 5 pollitos - $5\times5=25$ -) y por tanto puedes tener un total 3 repeticiones.  

```{r}
pollito_id <- 1:75
pollito_id <- sample(pollito_id,size = 75)
dieta <- paste0("D",rep(1:5,each=15))
length(dieta)
peso_d1 <- rnorm(mean = 160, n = 15,sd = 1)
peso_d2 <- rnorm(mean = 180, n = 15,sd = 1.4)
peso_d3 <- rnorm(mean = 130, n = 15,sd = 3)
peso_d4 <- rnorm(mean = 150, n = 15,sd = .6)
peso_d5 <- rnorm(mean = 155, n = 15,sd = 1.7)
pesos_all <- c(peso_d1,peso_d2,peso_d3,peso_d4,peso_d5)
pollitos <- data.frame(pollito_id, dieta,pesos_all)
pollitos <- pollitos[sample(pollito_id,size = 75),]
```
```{r,eval=FALSE}
# Imprimamos una parte del data.frame
print(pollitos[c(1:3,21:23,31:33,51:53,71:73),])
```


```{r,results='asis',echo=FALSE}
library(knitr)
kable(pollitos[c(1:3,21:23,31:33,51:53,71:73),])
```

### Indexación de `data.frames`

La indexación de los `data.frames` es idéntica al de las matrices; sin embargo, tiene una ventaja adicional, esta ventaja radica en que podemos llamar una columana completa indicando el nombre de esta en vez del número. De este modo en el ejemplo de pollitos, no importa si no sabemos la posición exacta de la columna **dieta** R la encontrará por nosotros. 

Veamos como hacerlo, imprimamos los primeros 10 elementos de la columana **dieta**
```{r}
pollitos[1:10,c("dieta")]
```

Otra forma de realizar la operación anterior es utilizando el símbolo de **$\$$**
```{r}
pollitos$dieta[1:10]
```


### Las listas

Es momento de introducir a uno de los objetos estrella de R, este es el objeto lista. Al igual que los vectores, las listas son arreglos unidimensionales con la peculiaridad de que los elementos que las integran pueden ser de varias clases, por ejemplo, `data.frames`, `matrices`, `vectores`, `rasters`, etc. 
A continuación veamos cómo crear una lista que contiene como elementos un `data.frame`, un `vector` y una `lista`, esta se crea con el comando `list()`

```{r}
# un vector de numeros aleatorio del 0 a la 1
vector <- runif(10)
# Un subconjunto del DF pollitos
data_frame_pollito <- pollitos[1:10,]
# uan lista
sublista <- list(a=1:10)

lista <- list(vector=vector, pollitos_df = data_frame_pollito, sublista=sublista)
print(lista)
```

### Extracción de los elementos de la lista

Como habíamos visto en la sección anterior, las listas se comportan como vectores y por tanto la forma de extraer un elemento de esta simplemente es ocupando la sintaxis `lista[[element_index]]`. 

```{r}
# El segundo elemento de la lista es el DF pollitos
lista[[2]]
```

Otra forma de extraer un elemento de la lista es con la sintaxis `lista$nombre_elemento`

```{r}
lista$pollitos_df
```

o bien `lista[["nombre_elemento"]]`

```{r}
lista[["pollitos_df"]]
```

### Extrayendo elementos contenidos en una lista de listas

Estamos interesados en extaer el elemento 10 del vector a contenido en la lista nombrada sublista que se encuentra dentro de nuestra lista principal. La sintaxis para extraer un elemento de una lista contenida dentro de otra lista es `lista[[indice_nivel_1]][[indice_nivel_2]][[indice_nivel3]]`
```{r}
# El elemento de lista que a la sublista que contiene al vector objetivo es el 3
# Esta sublista esta contituida por un solo elemento el cual es el vector a
# El elemento del vector a que nos interesa es el 10
indice_nivel_1 <- 3
indice_nivel_2 <- 1
indice_nivel_3 <- 10
lista[[indice_nivel_1]][[indice_nivel_2]][[indice_nivel_3]]
```

o bien 

```{r}
lista[["sublista"]][["a"]][[indice_nivel_3]]

```

### Agregando nuevos elementos a una lista 

Agreguemos un nuevo elemento (un vector de números aleatorios) a `lista`
```{r}
lista[["nuevo_elem"]] <- rnorm(30)
lista
```

o bien 

```{r}
lista$nuevo_elem_2 <- rbinom(30,size = 1,prob = 0.5)
lista
```

## Leyendo datos en R

Se pueden importar datos tabulados provenientes de varios formatos. Los más comunes son `.csv`,`.txt` y `.xls`. Los comandos para leer estos formatos son `read.csv`, `read.table`, `read.xls` (en el paquete `gdata`)  y `loadWorkbook` (en el paquete `XLConnect`).

En este documento veremos cómo cargar datos con los comandos `read.csv` y `read.table`. El primero sirve para leer datos separados por comas y el segundo por tabulaciones. 

Algunas bases de datos contienen otro tipo de separadores, tales como ";" ":" o cualquier otro caracter. Tanto `read.csv` como `read.table` tienen un argumento que perimite indicar el caracter sepador, este argumento es `sep = "caracter"`. Así, si nuestra base de datos estuviera separada por ";", sólo tendríamos que indicarlo de la siguiente manera: `sep=";"`.

Veamos algunos ejemplos concretos.

- Datos separados por comas

```{r}
df_csv <- read.csv("Arichivos_01Intro/data_Clean.csv")
head(df_csv)
```

- Datos separados por tabulaciones

```{r}
df_tab <- read.table("Arichivos_01Intro/ambys_data_dynamic_map.txt",header = T)
head(df_tab[,1:4])
```

- Usando `read.csv` para leer datos separados por tabulaciones

```{r}
df_tab_to_csv <- read.csv("Arichivos_01Intro/ambys_data_dynamic_map.txt",header = T,sep=" ")
head(df_tab_to_csv[,1:4])
```

**Nota:** una cuestión que debemos de tomar en cuenta cuando leemos datos en R es la codificación de nuestro sistema, ya que esto puede causar que no podamos leer un archivo. Algunas de las codificaciones más frecuentes son: `UTF-8` (default en MAC), `ASCII`, `WINDOWS-1252` y las `ISO-xxxx-x`. En R podemos especificar la codificación con el argumento `fileEncoding` de las funciones `read.csv` y `read.table`

```{r}
d <- read.csv("Arichivos_01Intro/ambys_data_dynamic_map.txt",header = T,sep=" ",fileEncoding = "UTF-8")
head(d[,5:7])
```

### Un ejemplo de como leer archivos de Excel

Como se mencionó anteriormente, en R es posible leer archivos de Excel utilizando las funciones `read.xls` y `loadWorkbook` de los paquetes `gdata` y `XLConnect` respectivamente. Veamos cómo instalar estos paquetes para utilizar las funciones señaladas.

- Con `read.xls` sólo tenemos que señalar la ruta donde se encuentra nuestro ***xls*** y la hoja del libro.

```{r}
# install.packages("gdata")
library(gdata)
d_xls <- read.xls("Arichivos_01Intro/data_Clean.xlsx",sheet = 1)
head(d_xls)
```

Veamos cómo hacer lo anterior con el paquete `XLConnect`

```{r}
library(XLConnect)
lib_xls <- loadWorkbook("Arichivos_01Intro/data_Clean.xlsx")
# Mostrar las hojas dispobles
getSheets(lib_xls)
# Cargar una hoja
d_xlsC <- readWorksheet(object = lib_xls,sheet = "ROC")
head(d_xlsC)

```


## Estructuras de Control y Loops

Programar implica escribir instrucciones relativamente complejas y repetir de manera iterada algunas de ellas. Hay dos grandes tipos de programación: 

1) **La programación imperativa** en donde se le indica a la computadora de manera consecutiva un conjunto de operaciones.

2) **La programación declarativa** en donde se da una descripción del resultado final (*i.e* HTML, $\LaTeX$) sin especificar cómo se obtiene tal resultado. 

Dentro de cada uno de estos estilos generales hay subdivisiones y algunos programas pueden contener varios aspectos de ellos. De manera específica en R, podemos encontrar a la programación modular (paquetes), la orientada a objetos y funcional.  

A continuación veremos unas estructuras conocidas como estructuras de control. Estas controlan cuántas veces una operación debe de repetirse. 

### La sentencia `if`

`if` es una sentencia cuya entrada es una operación de tipo lógica y nos permite probar **si** alguna condición se cumple o no. El diagrama de flujo para la sentencia `if` es el siguiente

![](Figuras_01Intro/if_else.png)

La sintaxis `if` en R:

```{r eval=FALSE}
if (condicion) {
  comandos o operaciones cuando TRUE
  }
if (condicion) {
  comandos o operaciones cuando TRUE
} else {
    comandos o operaciones cuando FALSE
  }

```

Imaginemos que nos interesa hacer un conjunto de operaciones sólo sobre los números divisibles entre 2 (pares) y descartar aquellos números que no son pares, a continuación veremos cómo utilizar if para lograr nuestro cometido.

```{r}
n1 <- 1
n2 <- 2
n3 <- 3
n4 <- 4

if(n1 %% 2 == 0){
  cat(n1,"Es par")
} else {
  cat(n1, "No es par")
}

if(n2 %% 2 == 0){
  cat(n2,"Es par")
} else {
  cat(n2, "No es par")
}


if(n3 %% 2 == 0){
  cat(n3,"Es par")
} else {
  cat(n3, "No es par")
}

if(n4 %% 2 == 0){
  cat(n4,"Es par")
} else {
  cat(n4, "No es par")
}


```


### `for` loop

Supongamos que saber cuáles son los números que son pares en un vector de 100 elementos; esto implicaría repetir 100 veces el código de la sección anterior. La sentencia `for` permite especificar con tan sólo una pocas líneas de código operaciones que se repiten `n` veces.

La sintaxis del for loop en R es
```{r eval=FALSE}
for (iterador in vector) {comandos o operaciones}

```

```{r}
# Genero una secuencia de números enteros (del 150 al 550) aleatoria
vec_num <- sample(150:550,size = 100,replace = F)
# Nuestro vector es 
print(vec_num)

for(n in vec_num){
  if(n %% 2 == 0)
    cat(n,"Es par\n") 
  else 
    cat(n, "No es par\n")
}

```

Alternativamente 

```{r eval=FALSE}
# Iteramos sobre los elementos de vec_num
vec_size <- length(vec_num)
for(iterador in 1:vec_size){
  n <- vec_num[iterador]
   if(n %% 2 == 0)
    cat(n,"Es par\n") 
  else 
    cat(n, "No es par\n")
}
```

##### Ejemplos un poco más laboriosos

Supongan que ahora se les pide guardar en un vector los números que son pares y los que no lo son en otro (para números enteros son los impares).La idea para solucionar nuestro problema es simple, apliquemos el **algoritmo par o impar** y vayamos guardando ("rellenando") los resultados en un vector nulo (vacío).

```{r}
vec_pares <- NULL
vec_impares <- NULL
# Iteramos sobre los elementos de vec_num
vec_size <- length(vec_num)

for(iterador in 1:vec_size){
  n <- vec_num[iterador]
   if(n %% 2 == 0){
     vec_pares[iterador] <-  n
   }
  else{
    vec_impares[iterador] <- n
  } 
}
```

En el vector `vec_pares` se generaron de manera automática `NA`s (Not Aviable) cuando la condición es par no se cumplió (R lo hace de manera automática). Lo mismo ocurrió para el vector `vec_impares` cuando la otra condición no se cumplió (condición es impar). 

Veamos cómo quitar los `NA`s.

```{r}
vec_pares_limpio <- as.vector(na.omit(vec_pares))
print(vec_pares_limpio)
vec_impares_limpio <-as.vector( na.omit(vec_impares))
print(vec_impares_limpio)
```

De forma similar podemos filtrar los datos con el comando `is.na`. Debido a que estamos interesados en los datos que no son `NA` usamos el comando de negación `!` para preguntar cuáles no son `NA`. Finalmente, con el comando `which` podemos saber las posiciones del vector `vec_pares` que no son `NA`.

```{r}
vec_pares_limpio <- vec_pares[which(!is.na(vec_pares))]
vec_impares_limpio <- vec_impares[which(!is.na(vec_impares))]
```


Si nos preguntaramos de nuestro vector original (`vec_num`) cuantos son pares y cuantos son impares...

```{r}
cat("El numero de enteros pares en vec_num fue de",length(vec_pares_limpio),"\n")
cat("El numero de enteros impares en vec_num fue de",length(vec_impares_limpio),"\n")
```

### `while` loop 

Habrá situaciones donde no sabemos cuántas iteraciones exactas necesitamos para llegar a cierto resultado. Será necesario hacer los cálculos y evaluar el resultado en cada iteración hasta que la condición que buscamos se cumpla. En esta situaciones podemos ocupar el ciclo `while`.

Supongamos que se nos pide calcular cuál es el número de la sucesión de [Fibonacci](https://es.wikipedia.org/wiki/Sucesi%C3%B3n_de_Fibonacci) más cercano al 400. El algoritmo para encontrar el $n-esimo$ término de la sucesión de Fibonacci es el siguiente 

$$ f_{n} = f_{n-1} + f_{n-2}$$

con $f_{1}=0$, $f_{2}=1$ y $f_{3}=1$. Ahora vemos cómo generar la secuencia de números de Fibonacci menores a 400 usando `while`.

```{r}
fib_1 <- 0
fibonacci <- c(fib_1)
fib_2 <- 1


while(fib_2 < 400){
  fib_n <- fib_1 + fib_2 
  fibonacci <- c(fibonacci,fib_2)
  fib_1 <- fib_2
  fib_2 <- fib_n

}

print(fibonacci)
```

¿Cuál es la posición del elemento de la sucesión más cercano a 400?
```{r}
print(length(fibonacci))
```


## Funciones definidas por el usuario.

Es común que hagamos ciertas operaciones de manera repetida y como consecuencia de ello tengamos que duplicar código que ya hemos ocupado con anterioridad. Lo anterior hace nuestros programas o scripts sean enormes y con mucha información redundante. Las funciones definidas por el usuarios precisamente están pensadas para que cuando tengamos que hacer una operación de manera repetida podamos llamar código con una sola instrucción sin tener que escribir todo nuevamente.

En R podemos definir nuestras propias funciones de manera fácil. Veremos cómo definir una función para pregruntar si un número entero es par o impar. Asimismo, definieremos una función para generar los primeros $n$ números de la secuencia de Fibonacci.

### Función es_par

```{r}
es_par <- function(x){
  # Cheamos que x es entero
  if(x%%1==0){
    # Checamos si es par
    if(x%%2==0){
      return(TRUE)
    }
    else
      return(FALSE)
  }
  # Mensaje notificando que x no es entero
  warning("El numero tiene que ser un numero entero")
}
```

Probemos nuestra función

```{r}
# Primero con un numero que no es entero
es_par(2.2)
# Ahora con un impar
es_par(3)
# Finalmente con un par
es_par(18)
```


## La operaciones vectorizadas 

Dentro de las críticas más fuertes que se le hacen a R es que es un lenguaje "lento". Una de las razones de ello, es que al ser un leguaje interpretado, R pregunta el tipo de variable (integer, floating, char, etc) en el tiempo de ejecución, sus instrucciones se traducen o interpretan una a una, cada vez que se ejecuta el programa. Cuando asignamos un valor a una variable, digamos `a <- 1.0` lo que hace el interprete de `R` es preguntar:

- Ese número `1.0` es de tipo flotante  
- La variable `a` es de tipo numérica
- Poner un lugar en la memoria donde almacenar el `1.0`
- Registar "a" como un puntero a ese lugar de memoria.

Para una explicación maravillosa sobre este tópico ver el artículo  de [Noam Ross](http://www.noamross.net/blog/2014/4/16/vectorization-in-r--why.html)

En los leguajes compliados (`C`, `C++`, `fortran`)  declaramos los tipos de las variables desde un principio, sus instrucciones se traducen a código máquina de manera directa y optimizada mediante un compilador, lo que los hace más efecientes. 

En R una forma de abordar el problema de eficiencia es utilizando operaciones vectorizadas siempre que sea posible. Las operaciones vectorizadas permiten a R llamar funciones de alto nivel que ejecutan código de `C`, lo que resulta en programas mucho más rápidos.

Comparemos el rendimiento de operaciones no vectorizadas vs. vectorizadas. 

### Operaciones no vectorizadas vs. vectorizadas. 

Sea df_occs una base de datos con puntos de presencia de varias especies de reptiles y anfibios; suponga que se le pide filtar los datos de presencia por especie y contruir una lista donde cada elemento de ella es un `data.frame` que contiene los datos de cada especie. Veremos cómo hacer este filtrado utilizando operaciones no vectorizadas y vectorizadas. Haremos uso de la función `system.time` para medir el tiempo que tarde en correr los algoritmos...

Primero leemos la base de datos de los puntos de presencia y exploramos la base de datos (BD).

```{r}
occs_bd <- read.csv("./Arichivos_01Intro/occs_rep_amf.csv")
# Dimensiones del DF.
dim(occs_bd )
# Una explo de la BD (mostrando solo 6 registros)
head(occs_bd,6)
# Los nombres de las variables de la BD.
names(occs_bd)
# Los nombres de las especies
print(unique(occs_bd$name))
```


### Algoritmo de búsqueda no vectorizado

Primero definimos la lista en donde guardaremos los `data.frames` de cada especie. Nótese que la lista tendrá tantos elementos como especies en la BD.

```{r}
# Creamos una lista vacia
occs_df_list <- list()
# Guardamos los nombres de las especies en un vector
sp_names <- unique(occs_bd$name)
```

Ahora implementamos el algorimo de búsqueda. La idea básica es ir recorriendo toda la columana `name` de la base de datos `occs_bd` e ir preguntando cuál registro cumple la condición `occs_bd$name == sp_name_i`; posteriormente almacenar estos índices en un vector llamado `sp_index` con los índices que cumplen la condición. Finalemente hacer un subset de `occs_bd` con `sp_index`.

```{r}
# Vector donde guardare los idices (vacio)
sp_index <- c()
# Iteraremos 
tiempo_novec <- system.time({
  # Recorremos cada especie en sp_names
  for(spi in 1:length(sp_names)){
    # Especie i en la iteracion i
    sp_name_i <- sp_names[spi]
    # Recorremos cada registro en BD 
  for(registro in 1:dim(occs_bd)[1]){
    # Preguntamos si coincide el nombre sp_name_i con el registro occs_bd$name (condicion 1)
    if(sp_name_i == occs_bd$name[registro]){
      sp_index <- c(sp_index,registro)
    }
  }
  # Los registros que cumplieron la condicion 1
  # en sp_index son ocupados para hacer el subset
  # Guardamos estos en la lista
  occs_df_list[[spi]] <- occs_bd[sp_index,]
  # reinializamos el vector sp_index
  sp_index <- c()
  }
  # Le ponemos nombre de la sp a cada elemento de la lista
  names(occs_df_list) <- sp_names
})
```

Cuánto tardó en correr?
```{r}
print(tiempo_novec)
```


#### Algoritmo de búsqueda vectorizado

Utilizaremos un comando de mi lista de estrellas, este es `which`

```{r}
# Creamos una lista vacia
occs_df_list_vec <- list()
# nuevamente definamos una variable con los nombres de sps
sp_names <- unique(occs_bd$name)

```

Combinamos la operación vectorizada `which` con el ciclo `for`

```{r}
tiempo_vec <- system.time({
  for(spi in 1:length(sp_names)){
    # Especie i en la iteracion i
    sp_name_i <- sp_names[spi]
    sp_index_vec <- which(sp_name_i == occs_bd$name)
    occs_df_list_vec[[spi]] <- occs_bd[sp_index_vec,]
  }
})
names(occs_df_list_vec) <- sp_names
```

Cuánto tardo con el vectorizado??

```{r}
print(tiempo_vec)
```

Cuántas veces corrió más rápido el código vectorizado?

```{r}
tiempo_ratio <- tiempo_novec[[3]]/tiempo_vec[[3]]
print(tiempo_ratio)
```


### La familia `apply`

La familia de funciones apply tienen como objetivo operar sobre estructuras de datos como `matrix`, `data.frames`, `arrays`, y `lists` de forma repetitiva. Estas funciones aplican una función sobre un conjunto de datos y devulven un arreglo el cual puede ser una matriz, una tabla de datos o una lista. Una característica de ellas, es que permiten evitar los loops, por lo que serán necesarias menos lineas de código para llegar a un mismo resultado (el código suele ser más elegante).

Entre los R-programadores se suele decir que es más R-tónico (en alusión a pythonico) utilizar las funciones de la familia `apply` sobre los loops.

Veamos cuales funciones conforman esta familia y sus ouputs (es información la tomé de [esta página](https://nsaunders.wordpress.com/2010/08/20/a-brief-introduction-to-apply-in-r/)):

| Función         |                                                             |
------------------|--------------------------------------------------------------
| base::apply     |        Apply Functions Over Array Margins                   |
| base::by        |        Apply a Function to a Data Frame Split by Factors    |
| base::eapply    |        Apply a Function Over Values in an Environment       |
| base::lapply    |        Apply a Function over a List or Vector               |
| base::mapply    |        Apply a Function to Multiple List or Vector Arguments|
| base::rapply    |        Recursively Apply a Function to a List               |
| base::tapply    |        Apply a Function Over a Ragged Array                 |


#### lapply

La función lappy regresa una lista cuyos elementos pueden ser cualquier tipo de estructura de datos (`matrix`, `data.frames`, `arrays`, `lists`, etc.).

Veremos cómo implementar nuestro algortimo de búsqueda y filtrado de datos por especie utilizando las `apply` functions.

Como se había mencionado anteriormente las funciones de esta gran familia aplican una función (generalmente definida por el usuario) sobre una estructura de datos y por lo tanto, para implementar nuestro algoritmo de búsqueda será necesario definir nuestra función.

```{r}
# Funcion de busqueda
# sp_name: Es el nombre de la especie
# bd_datos: data.frame con los datos de presencia
# col_name: Columna en el data.frame sobre la que se hara la busqueda
find_sp <- function(sp_name, bd_datos,col_name){
  # Preguntamos si coincide el nombre sp_name con el registro occs_bd[,col_name] (condicion 1)
  sp_index <- which(bd_datos[,col_name] == sp_name)
  # Subset con los datos que cumplen la condicion 1
  sp_df <- bd_datos[sp_index,]
  return(sp_df)
}
```

Apliquemos nuestra función usando la sintaxis `lapply`. En esta sólo hay que especificar un vector de índices o listas (X) sobre el cual la función que definimos va a operar (`find_sp`).

```{r}
sp_names <- unique(occs_bd$name)
tiempo_lapply <- system.time({
  occs_df_list_apply <- lapply(sp_names, 
                               function(sp) 
                                 find_sp(sp,bd_datos = occs_bd,col_name = "name") )
  
})

```

## Usando una funcón que llama c

```{r}



tiempo_split <- system.time({
  occs_bdList <- occs_bd %>% split(.$name)
})
```



Comparemos los rendimientos de nuestras implementaciones:

```{r}
cat("Tiempo de ejecucion:", tiempo_novec[[3]],"algoritmo no vectorizado\n")
cat("Tiempo de ejecucion:", tiempo_vec[[3]],"algoritmo vectorizado\n")
cat("Tiempo de ejecucion:", tiempo_lapply[[3]],"algoritmo vectorizado y lappy\n")
cat("Tiempo de ejecucion:", tiempo_split[[3]],"split\n")
```

## `purrr` programación funcional 

La idea es `mapear` una los elementos de una lista y aplicar una función. Calculemos el polígono convexo de los puntos de presencia de las especies 

- Primero creamos la función para estimar los puntos que formaran el polígono convexo.
```{r}
create_convex <- function(sp_db,sp_name,long,lat){
  ch <- chull(sp_db[,c(long,lat)])
  coords <- sp_db[c(ch, ch[1]), c(long,lat)]  
  coords <- cbind(sp_name,coords)
  return(coords)
}
```

- Convertimos en una lista el `data.frame` de la base de datos de presencia
```{r}
occs_bdList <- occs_bd %>% split(.$name)
poligonos <- occs_bdList %>% 
  purrr::map(~create_convex(sp_db = .x,
                           sp_name = .x$name[1],
                           long = "longitude",
                           lat = "latitude"))
```

Graficaremos los polígonos convexos de 5 especies tomadas al azar
```{r}
pol_subm <- poligonos[sample(length(poligonos),5)]
pol_subm %>% purrr::map(~ plot(.x$longitude,.x$latitude,type="l"))
```








